txt_obj_name = ["Casket","Shrine","Casket","LargeUrn","LargeChestRight","LargeChestLeft","Barrel","TowerTome","Urn","Bench","BarrelExploding","RogueFountain","DoorGateLeft","DoorGateRight","DoorWoodenLeft","DoorWoodenRight","CairnStoneAlpha","CairnStoneGamma","CairnStoneBeta","CairnStoneDelta","CairnStoneLambda","CairnStoneTheta","DoorCourtyardLeft","DoorCourtyardRight","DoorCathedralDouble","CainGibbet","DoorMonasteryDoubleRight","HoleAnim","Brazier","InifussTree","Fountain","Crucifix","Candles","Candles","Standard","Standard","TorchTiki","TorchWall","RogueBonfire","River","River","River","River","River","AmbientSoundGenerator","Crate","AndarielDoor","RogueTorch","RogueTorch","CasketR","CasketL","Urn","Casket","RogueCorpse","RogueCorpse","RogueCorpseRolling","CorpseOnStick","CorpseOnStick","TownPortal","PermanentTownPortal","InvisibleObject","DoorCathedralLeft","DoorCathedralRight","DoorWoodenLeft","InvisibleRiverSound","InvisibleRiverSound","Ripple","Ripple","Ripple","Ripple","ForestNightSound","ForestNightSound","YetiDung","TrappDoor","DoorByActDock","SewerDrip","HealthOrama","InvisibleTownSound","Casket","Obelisk","ForestAltar","BubblingPoolOfBlood","HornShrine","HealingWell","BullHealthShrine","SteleDesertMagicShrine","TombLargeChestL","TombLargeChestR","Sarcophagus","DesertObelisk","TombDoorLeft","TombDoorRight","InnerHellManaShrine","LargeUrn","LargeUrn","InnerHellHealthShrine","InnerHellShrine","TombDoorLeft","TombDoorRight","DurielsLairPortal","Brazier","FloorBrazier","Flies","ArmorStandRight","ArmorStandLeft","WeaponRackRight","WeaponRackLeft","Malus","PalaceHealthShrine","Drinker","Fountain","Gesturer","DesertFountain","Turner","Fountain","SnakeWomanShrine","JungleTorch","Fountain","WaypointPortal","DungeonHealthShrine","JerhynPlaceHolder","JerhynPlaceHolder","InnerHellShrine","InnerHellShrine","InnerHellHiddenStash","InnerHellSkullPile","InnerHellHiddenStash","InnerHellHiddenStash","SecretDoor","ActWildernessWell","VileDogAfterglow","CathedralWell","ArcaneSanctuaryShrine","DesertShrine","DesertShrine","DesertShrine","DesertWell","CaveWell","ActLargeChestRight","ActTallChestRight","ActMediumChestRight","DesertJug","DesertJug","ActLargeChest","InnerHellWaypoint","ActMediumChestRight","ActLargeChestRight","ActLargeChestLeft","TaintedSunAltar","DesertShrine","DesertShrine","HoradricOrifice","TyraelsDoor","GuardCorpse","HiddenStashRock","ActWaypoint","ActWildernessWaypoint","SkeletonCorpseIsAnOxymoron","HiddenStashRockB","SmallFire","MediumFire","LargeFire","ActCliffHidingSpot","ManaWell","ManaWell","ManaWell","ManaWell","ManaWell","HollowLog","JungleHealWell","SkeletonCorpseIsStillAnOxymoron","DesertHealthShrine","ManaWell","LooseRock","LooseBoulder","MediumChestLeft","LargeChestLeft","GuardCorpseOnAStick","Bookshelf","Bookshelf","JungleChest","TombCoffin","JungleMediumChestLeft","JungleShrine","JungleStashObject","JungleStashObject","JungleStashObject","JungleStashObject","DummyCainPortal","JungleShrine","JungleShrine","TeleportationPad","LamEsensTome","StairsL","StairsR","FloorTrap","JungleShrine","TallChestLeft","MephistoShrine","MephistoShrine","MephistoShrine","MephistoManaShrine","MephistoLair","StashBox","StashAltar","MafistoHealthShrine","ActWaterRocks","Basket","Basket","ActWaterLogs","ActWaterRocksGirl","ActWaterBubbles","ActWaterLogsX","ActWaterRocksB","ActWaterRocksGirlC","ActWaterRocksY","ActWaterLogsZ","WebCoveredTree","WebCoveredTree","WebCoveredTree","WebCoveredTree","Pillar","Cocoon","Cocoon","SkullPileH","OuterHellShrine","ActWaterRocksGirlW","ActBigLog","SlimeDoor","SlimeDoor","OuterHellShrine","OuterHellShrine","PillarH","ActBigLogC","ActBigLogD","HellHealthShrine","ActTownWaypoint","WaypointH","BurningBodyTown","GchestL","GchestR","GchestR","GLchestL","SewersRatNest","BurningBodyTown","SewersRatNest","ActBedBed","ActBedBed","HellManaShrine","ExplodingCow","GidbinnAltar","GidbinnAltarDecoy","DiabloRightLight","DiabloLeftLight","DiabloStartPoint","ActCabinStool","ActCabinWood","ActCabinWood","HellSkeletonSpawnNW","ActHolyShrine","TombsFloorTrapSpikes","ActCathedralShrine","ActJailShrine","ActJailShrine","ActJailShrine","MaggotLairGooPile","Bank","WirtCorpse","GoldPlaceHolder","GuardCorpse","DeadVillager","DeadVillager","DummyFlameNoDamage","TinyPixelShapedThingie","CavesHealthShrine","CavesManaShrine","CaveMagicShrine","ActDungeonManaShrine","ActSewersMagicShrine","ActSewersHealthWell","ActSewersManaWell","ActSewersMagicShrine","ActBrazierCeller","ActTombAnubisCoffin","ActBrazier","ActBrazierTall","ActBrazierSmall","ActCellerWaypoint","HarumBedBed","IronGrateDoorLeft","IronGrateDoorRight","WoodenGrateDoorLeft","WoodenGrateDoorRight","WoodenDoorLeft","WoodenDoorRight","TombsWallTorchLeft","TombsWallTorchRight","ArcaneSanctuaryPortal","ActHaramMagicShrine","ActHaramMagicShrine","MaggotHealthWell","MaggotManaWell","ArcaneSanctuaryMagicShrine","TeleportationPad","TeleportationPad","TeleportationPad","DummyArcaneThing","DummyArcaneThing","DummyArcaneThing","DummyArcaneThing","DummyArcaneThing","DummyArcaneThing","DummyArcaneThing","HaremDeadGuard","HaremDeadGuard","HaremDeadGuard","HaremDeadGuard","HaremEunuchBlocker","ArcaneHealthWell","ArcaneManaWell","TestData","ActTombWell","ActSewerWaypoint","ActTravincalWaypoint","ActSewerMagicShrine","ActSewerDeadBody","ActSewerTorch","ActKurastTorch","MafistoLargeChestLeft","MafistoLargeChestRight","MafistoMediumChestLeft","MafistoMediumChestRight","SpiderLairLargeChestLeft","SpiderLairTallChestLeft","SpiderLairMediumChestRight","SpiderLairTallChestRight","SteegStone","GuildVault","TrophyCase","MessageBoard","MephistoBridge","HellGate","ActKurastManaWell","ActKurastHealthWell","HellFire","HellFire","HellFire","HellLava","HellLava","HellLava","HellLightSource","HellLightSource","HellLightSource","HoradricCubeChest","HoradricScrollChest","StaffOfKingsChest","YetAnotherTome","HellBrazier","HellBrazier","DungeonRockPile","ActDungeonMagicShrine","ActDungeonBasket","OuterHellHungSkeleton","GuyForDungeon","ActDungeonCasket","ActSewerStairs","ActSewerStairsToLevel","DarkWandererStartPosition","TrappedSoulPlaceHolder","ActTownTorch","LargeChestR","InnerHellBoneChest","HellSkeletonSpawnNE","ActWaterFog","DummyNotUsed","HellForge","GuildPortal","HratliStartPosition","HratliEndPosition","BurningTrappedSoul","BurningTrappedSoul","NatalyaStartPosition","StuckedTrappedSoul","StuckedTrappedSoul","CainStartPosition","StairSR","ArcaneLargeChestLeft","ArcaneCasket","ArcaneLargeChestRight","ArcaneSmallChestLeft","ArcaneSmallChestRight","DiabloSeal","DiabloSeal","DiabloSeal","DiabloSeal","DiabloSeal","SparklyChest","PandamoniumFortressWaypoint","InnerHellFissure","HellMesaBrazier","Smoke","ValleyWaypoint","HellBrazier","CompellingOrb","KhalimChest","KhalimChest","KhalimChest","SiegeMachineControl","PotOTorch","PyoxFirePit","ExpansionChestRight","ExpansionWildernessShrine","ExpansionWildernessShrine","ExpansionHiddenStash","ExpansionWildernessFlag","ExpansionWildernessBarrel","ExpansionSiegeBarrel","ExpansionWoodChestLeft","ExpansionWildernessShrine","ExpansionManaShrine","ExpansionHealthShrine","BurialChestLeft","BurialChestRight","ExpansionWell","ExpansionWildernessShrine","ExpansionWildernessShrine","ExpansionWaypoint","ExpansionChestLeft","ExpansionWoodChestRight","ExpansionSmallChestLeft","ExpansionSmallChestRight","ExpansionTorch","ExpansionCampFire","ExpansionTownTorch","ExpansionTorch","ExpansionBurningBodies","ExpansionBurningPit","ExpansionTribalFlag","ExpansionTownFlag","ExpansionChandelier","ExpansionJar","ExpansionJar","ExpansionJar","ExpansionSwingingHeads","ExpansionWildernessPole","AnimatedSkullAndRockPile","ExpansionTownGate","SkullAndRockPile","SiegeHellGate","EnemyCampBanner","EnemyCampBanner","ExpansionExplodingChest","ExpansionSpecialChest","ExpansionDeathPole","ExpansionDeathPoleLeft","TempleAltar","DrehyaTownStartPosition","DrehyaWildernessStartPosition","NihlathakTownStartPosition","NihlathakWildernessStartPosition","IceCaveHiddenStash","IceCaveHealthShrine","IceCaveManaShrine","IceCaveEvilUrn","IceCaveJar","IceCaveJar","IceCaveJar","IceCaveJar","IceCaveJar","IceCaveMagicShrine","CagedWussie","AncientStatue","AncientStatue","AncientStatue","DeadBarbarian","ClientSmoke","IceCaveMagicShrine","IceCaveTorch","IceCaveTorch","ExpansionTikiTorch","WorldstoneManaShrine","WorldstoneHealthShrine","WorldstoneTomb","WorldstoneTomb","WorldstoneTomb","WorldstoneMagicShrine","WorldstoneTorch","WorldstoneTorch","ExpansionSnowyManaShrine","ExpansionSnowyHealthShrine","ExpansionSnowyWell","WorldstoneWaypoint","ExpansionSnowyMagicShrine","ExpansionWildernessWaypoint","ExpansionSnowyMagicShrine","WorldstoneWell","WorldstoneMagicShrine","ExpansionSnowyObject","ExpansionSnowyWoodChestLeft","ExpansionSnowyWoodChestRight","WorldstoneMagicShrine","ExpansionSnowyWoodChestLeft","ExpansionSnowyWoodChestRight","SnowySwingingHeads","SnowyDebris","PenBreakableDoor","ExpansionTempleMagicShrine","ExpansionSnowyPoleMR","IceCaveWaypoint","ExpansionTempleMagicShrine","ExpansionTempleWell","ExpansionTempleTorch","ExpansionTempleTorch","ExpansionTempleObject","ExpansionTempleObject","WorldstoneMrBox","IceCaveWell","ExpansionTempleMagicShrine","ExpansionTempleHealthShrine","ExpansionTempleManaShrine","BlacksmithForge","WorldstoneTombLeft","WorldstoneTombLeft","WorldstoneTombLeft","IceCaveBubblesU","IceCaveBubblesS","RedBaalsLairTomb","RedBaalsLairTombLeft","RedBaalsLairTomb","RedBaalsLairTombLeft","RedBaalsLairTomb","RedBaalsLairTombLeft","RedBaalsLairMrBox","RedBaalsLairTorch","RedBaalsLairTorch","CandlesTemple","TempleWaypoint","ExpansionDeadPerson","TempleGroundTomb","LarzukGreeting","LarzukStandard","TempleGroundTombLeft","ExpansionDeadPerson","AncientsAltar","ArreatSummitDoorToWorldstone","ExpansionWeaponRackRight","ExpansionWeaponRackLeft","ExpansionArmorStandRight","ExpansionArmorStandLeft","ArreatsSummitTorch","ExpansionFuneralSpire","ExpansionBurningLogs","IceCaveSteam","ExpansionDeadPerson","BaalsLair","FrozenAnya","BBQBunny","BaalTorchBig","InvisibleAncient","InvisibleBase","BaalsPortal","ArreatSummitDoor","LastPortal","LastLastPortal","ZooTestData","KeeperTestData","BaalsPortal","FirePlaceGuy","DoorBlocker","DoorBlocker","GoodChest","NotSoGoodChest"]

#ref offset - for confirmation of pattern searches
#unitTable offset: 0x21E8CF0
#UI offset: 0x21F89AA
#expansion offset: 0x21F89BD
#data offset: 0x295DAA0
#menu offset: 0x2149E38
import requests
import math
import pymem
import pymem.pattern
import colorama
from colorama import init
from colorama import *
from termcolor import colored
init(autoreset=True)

from subprocess import PIPE, Popen
import json




class d2r_proc:
	def __init__(self):
		self.pm = None
		self.pm = pymem.Pymem("D2R.exe")
		self.process = self.pm
		self.player_unit = 0
		self.exp_pat = b"\xC7\x05....\x00\x00\x00\x00\x48\x85\xC0\x0F\x84....\x83\x78\x5C\x00\x0F\x84....\x33\xD2\x41"
		self.handle = self.pm.process_handle
		self.module = pymem.process.module_from_name(self.handle, "D2R.exe")
		self.base = self.pm.base_address
		self.exp_offset = self.get_exp_offset()
		self.starting_offset = self.get_unit_offset()
		self.game_info_offset = self.get_game_info_offset()
		self.ui_settings_offset = self.get_ui_settings_offset()
		self.menu_vis_offset = self.get_menu_vis_offset()
		self.chests=[]
		self.map_ox=0
		self.map_oy=0
		print(colored(":: Base address            -> {}".format(hex(self.base)), 'cyan'))


	def get_map_d2api(self,seed):
		#this requires the d2mapapi_piped.exe to be used with a local install of diablo2
		#prob just use the server instead
		p = Popen(["d2mapapi_piped.exe", "C:/Program Files/Diablo II"], stdin=PIPE, stdout=PIPE)
		#seed
		s = (seed).to_bytes(4, 'little')
		#difficulty
		d = (2).to_bytes(4, 'little')
		#map id
		m = (79).to_bytes(4, 'little')
		
		p.stdin.write(s)
		p.stdin.write(d)
		p.stdin.write(m)
		data,err = p.communicate()
		sd = data.decode('ascii','ignore')
		#nasty 
		sd = sd[sd.find('{'):]
		j = json.loads(sd,strict=False)	
		obj = j['objects']
		#get chests....
		chests = obj['580']
		#print(sd)
		map_offset_x = j['offset']['x']
		map_offset_y = j['offset']['y']
		self.chests = chests
		self.map_ox = map_offset_x
		self.map_oy = map_offset_y


	def get_map_json(self,seed):
		#map hosting
		base_url='http://34.69.54.92:8000'
		#gets a hell lower kurast json file
		#http://map.d2r-mapview.xyz:8080/v1/map/123456/2/79/
		url=base_url+'/'+str(seed)+'/2/79/1'
		print(url)
		resp = requests.get(url=url)
		j = resp.json()
		#data = json.loads(data,strict=False)	

		obj = j['objects']
		#get chests....
		chests = obj['580']
		#print(sd)
		map_offset_x = j['offset']['x']
		map_offset_y = j['offset']['y']
		self.chests = chests
		self.map_ox = map_offset_x
		self.map_oy = map_offset_y

		return True


	def get_map_json_old(self,seed):
		#map hosting
		base_url='http://34.69.54.92:8000'
		#gets a hell lower kurast json file
		#http://map.d2r-mapview.xyz:8080/v1/map/123456/2/79/
		url=base_url+'/'+str(seed)+'/2/79/1'
		print(url)
		resp = requests.get(url=url)
		data = resp.json()
		#data = json.loads(data,strict=False)	
		chests = []
		for key in data['objects']:
			if key['id']==580:
				chests.append(key)
		#print(chests)
		self.chests=chests
		#{"type":"map","id":79,"name":"Lower Kurast","offset":{"x":4960,"y":2760},"size":{"width":400,"height":320},
		self.map_ox = data['offset']['x']
		self.map_oy = data['offset']['y']
		print(self.chests)
		print(self._map_ox)
		print(self._map_oy)

		return True
		

	def get_game_info_offset(self):
		#unit table offset
		pat = b'\xE8....\x48\x8D\x0D....\x44\x88\x2D....'
		pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
		offset_buffer = self.process.read_int(pat_addr+8)
		game_info_offset = ((pat_addr - self.base)  + 7 -256 + 5 + offset_buffer)
		log = (":: Found game info offset  -> {}".format(hex(game_info_offset)))
		print(colored(log, 'cyan'))
		return game_info_offset

	def get_exp_offset(self):
		#expansion offset
		pat = b'\xC7\x05........\x48\x85\xC0\x0F\x84....\x83\x78\x5C.\x0F\x84....\x33\xD2\x41'
		#this works fine, shorter pattern
		pat = b'\xC7\x05........\x48\x85\xC0\x0F\x84....'
		pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
		offset_buffer = self.process.read_int(pat_addr-4)
		exp_offset = ((pat_addr - self.base) + offset_buffer)
		log = (":: Found exp offset        -> {}".format(hex(exp_offset)))
		print(colored(log, 'cyan'))
		return exp_offset

	def get_unit_offset(self):
		#unit table offset
		pat = b"\x48\x8d.....\x8b\xd1"
		pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
		offset_buffer = self.process.read_int(pat_addr+3)
		player_offset = ((pat_addr - self.base) + 7 + offset_buffer)
		log = (":: Found player offset     -> {}".format(hex(player_offset)))
		print(colored(log, 'cyan'))
		return player_offset

	def get_ui_settings_offset(self):
		#unit table offset
		pat = b"\x40\x84\xed\x0f\x94\x05"
		pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
		offset_buffer = self.process.read_int(pat_addr+6)
		ui_offset = ((pat_addr - self.base) + 10 + offset_buffer)
		log = (":: Found ui offset         -> {}".format(hex(ui_offset)))
		print(colored(log, 'cyan'))
		return ui_offset

	def get_menu_vis_offset(self):
		#menu vis offset
		#pat = b'\x8B\x05....\x89\x44\x24\x20\x74\x07'
		#?? search less direct matches?
		pat = b'\x8B\x05....\x89\x44..\x74\x07'
		pat_addr = pymem.pattern.pattern_scan_module(self.handle, self.module, pat)
		offset_buffer = self.process.read_int(pat_addr+2)
		menu_offset = ((pat_addr - self.base) + 6 + offset_buffer)
		log = (":: Found menu offset      -> {}".format(hex(menu_offset)))
		print(colored(log, 'cyan'))
		return menu_offset

	def get_player_offset(self,loops):
		found = False
		#if exp_offset==None:
		#	exp_offset = 0x21F89BD
		ui_offset = 0x21F89AA
		attempts=0
		name = ""
		new_offset=0

		for i in range(loops):
			attempts=i+0
			new_offset = (self.starting_offset)+(attempts-1)*8

			start_addr = self.base + new_offset
			#if(loops>1):
				#player_check = ("!! checking player unit    -> "+str(hex(new_offset)))
				#print(colored(player_check, 'red'))
			player_unit = self.process.read_longlong(start_addr)
			while player_unit>0:
				p_inventory = player_unit+0x90
				inventory = self.process.read_longlong(p_inventory)
				if(inventory):
					log = (":: Found inventory offset  -> {}".format(hex(self.base-inventory)))
					print(colored(log, 'cyan'))
					exp_char = self.process.read_ushort(self.base+self.exp_offset)
					base_check = self.process.read_ushort(inventory+0x30) !=1
					if(exp_char):
						log = (":: Expansion char          -> True")
						print(colored(log, 'cyan'))
						base_check = self.process.read_ushort(inventory+0x70) !=0

				if(base_check):
					#print("base checks")
					p_act = player_unit+0x20
					act_addr = self.process.read_ulonglong(p_act)
					map_seed_addr = act_addr +0x14
					map_seed = self.process.read_uint(map_seed_addr)
					self.map_seed = map_seed
					#print(map_seed)
					p_path = player_unit+0x38
					path_addr = self.process.read_longlong(p_path)

					x_pos = self.process.read_ushort(path_addr+0x02)
					y_pos = self.process.read_ushort(path_addr+0x06)

					p_unit_data = player_unit +0x10
					try:
						player_name_addr = self.process.read_longlong(p_unit_data)
					except:
						pass
					p_name = ""

					for i in range(16):
						name = name + str(chr(self.process.read_uchar(player_name_addr+i-1)))

					if(x_pos > 0 and y_pos >0 and len(str(map_seed))>6):
						if loops > 1:
							log = (":: Found player name       -> {}".format(name))
							print(colored(log, 'green'))
							log = (":: Found map seed          -> {}".format(map_seed))
							print(colored(log, 'green'))
							#print("xpos -> "+str(x_pos)+" ypos -> "+str(y_pos))
						new_offset = new_offset+0
						found = True
						self.player_unit = new_offset
						self.path_addr = path_addr
						return True

				new_offset = (player_unit+0x150)-self.base
				try:
					player_unit = self.process.read_longlong(player_unit +0x150)
				except:
					pass

	def find_info(self):
		startingAddress = self.base + self.player_unit
		playerUnit = self.process.read_ulonglong(startingAddress)

		pUnitData = playerUnit + 0x10
		playerNameAddress = self.process.read_ulonglong(pUnitData)
		playerName = self.process.read_string(playerNameAddress)
		
		pStatsListEx = self.process.read_ulonglong(playerUnit+0x88)
		statPtr = self.process.read_ulonglong(pStatsListEx+0x30)
		statCount = self.process.read_ulonglong(pStatsListEx+0x38)

		for i in range(statCount):

			statOffset = (i-1) * 8
			statEnum = self.process.read_ushort(statPtr + 0x2 + statOffset)
			if (statEnum == 12):
				self.player_level = self.process.read_uint(statPtr + 0x4 + statOffset)
			if (statEnum == 13):
				self.experience = self.process.read_uint(statPtr + 0x4 + statOffset)
			if (statEnum == 6):
				hp = self.process.read_uint(statPtr + 0x4 + statOffset)
				self.hp = hp >> 8
			if (statEnum == 7):
				maxhp = self.process.read_uint(statPtr + 0x4 + statOffset)
				self.max_hp = maxhp >> 8
		log = ":: LVL: " +str(self.player_level)+", HP: "+str(self.max_hp)+", EXP: "+str(self.experience)
		print(colored(log, 'yellow'))

		#get the level number
		pPathAddress = playerUnit + 0x38
		pPath = self.process.read_ulonglong(pPathAddress)
		pRoom1 = pPath + 0x20
		pRoom1Address = self.process.read_ulonglong(pRoom1)
		pRoom2 = pRoom1Address + 0x18
		pRoom2Address = self.process.read_ulonglong(pRoom2)
		pLevel = pRoom2Address + 0x90
		pLevelAddress = self.process.read_ulonglong(pLevel)
		dwLevelNo = pLevelAddress + 0x1F8
		levelNo = self.process.read_ulonglong(dwLevelNo)

		if not levelNo:
			log = "!! Did not find level num using player offset " +str(playerOffset)
			print(colored(log, 'red'))



		#get the map seed
		pAct = playerUnit + 0x20
		actAddress = self.process.read_ulonglong(pAct)


		if actAddress:
			mapSeedAddress = actAddress + 0x14
			if mapSeedAddress:
				mapSeed = self.process.read_uint(mapSeedAddress)
				self.map_seed = mapSeed
				#print("Found seed "+str(mapSeed)+ " at address " +str(mapSeedAddress))
			else:
				log = ("!! Did not find map seed at address "+(mapSeedAddress))
				print(colored(log, 'red'))

		#get the level number
		actAddress = self.process.read_ulonglong(pAct)
		pActUnk1 = actAddress + 0x70
		aActUnk2 = self.process.read_ulonglong(pActUnk1)
		aDifficulty = aActUnk2 + 0x830
		difficulty = self.process.read_ushort(aDifficulty)

		if difficulty==0:
			log = (":: current difficulty      -> Normal")
			print(colored(log, 'green'))

		if difficulty==1:
			log = (":: current difficulty      -> Nightmare")
			print(colored(log, 'green'))
		if difficulty==2:
			log = (":: current difficulty      -> Hell")
			print(colored(log, 'green'))

	def normalized_p(self):
		self.np_x = float(self.map_ox)/float(self.process.read_ushort(self.path_addr+0x02))
		self.np_y = float(self.map_oy)/float(self.process.read_ushort(self.path_addr+0x06))

	def get_ppos(self):
		self.x_pos = self.process.read_ushort(self.path_addr+0x02)
		self.y_pos = self.process.read_ushort(self.path_addr+0x06)

	def chest_dist(self):
		self.x_pos = self.process.read_ushort(self.path_addr+0x02)-self.map_ox
		self.y_pos = self.process.read_ushort(self.path_addr+0x06)-self.map_oy

		for chest in self.chests:
			chest_loc_x = chest['x']
			chest_loc_y = chest['y']
			odist = math.dist([chest_loc_x,chest_loc_y],[self.x_pos,self.y_pos])
			#print('dist - > ' + str(odist))
			#print('current pos ->  '+str(self.x_pos)+','+str(self.y_pos))

	def find_objects(self):
		self.super_chests =[]
		object_offset = self.starting_offset + (2 * 1024)
		attempts=0


		for i in range(256):
			attempts=i+0
			new_offset = object_offset + (8 * (i-1))
			item_addr = self.base + new_offset
			object_unit = self.process.read_longlong(item_addr)

			#print(i)
			while (object_unit>0):
				item_type = self.process.read_int(object_unit+0x00)
				if(item_type==2):
					file_no = self.process.read_int(object_unit+0x04)
					#160 small fire is super chest loc
					if file_no == 160 or file_no == 580  or file_no == 581:
						
						p_unit_data = self.process.read_ulonglong(object_unit + 0x10)
						#pObjectTxt = self.process.read_ulonglong(p_unit_data)
						#print(str(pObjectTxt))
						#sObjectTxt = self.process.read_string(p_unit_data, 16)
						#interactType = self.process.read_ushort(p_unit_data + 0x08)
						#shrineFlag = self.process.read_ushort(p_unit_data + 0x09)
						#shrineTxt = self.process.read_string(p_unit_data + 0x0c, 16)
						
						pPath = self.process.read_ulonglong(object_unit + 0x38)  
						objectx = self.process.read_ushort(pPath + 0x10)
						objecty = self.process.read_ushort(pPath + 0x14)
						self.x_pos = self.process.read_ushort(self.path_addr+0x02)
						self.y_pos = self.process.read_ushort(self.path_addr+0x06)
						odist = math.dist([objectx,objecty],[self.x_pos,self.y_pos])
						#print(self.y_pos)
						#print(self.x_pos)
						print(txt_obj_name[file_no-1] + " " + str(str(file_no)))	
						print('dist - > ' + str(odist))



				object_unit = self.process.read_longlong(object_unit + 0x150)



if __name__ == "__main__":
	#get new starting offsets
	d2 = d2r_proc()
	#find our player
	try:
		d2.get_player_offset(128)
	except:
		log = ("!! Unable to find player, are you at the title screen?")
		print(colored(log, 'red'))
		exit()
	d2.find_info()
	d2.get_ppos()
	d2.get_map_json(str(d2.map_seed))
	#d2.find_objects()
	d2.chest_dist()
